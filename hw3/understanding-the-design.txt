A scenegraph is composed of:
	1. root node
	2. nodes mapping (String to Node)
	3. meshes mapping (String to Polygon Mesh)
	4. textures mapping (String to String)
	5. ISceneGraphRenderer 

The root node is the root of a tree that contains all the objects to be displayed in the world. This node (representing the world) contains children trees that represent all of the objects this world contains. For example, a human is composed of an upper body, and a lower body. An upper body is composed of a left arm, a right arm, a torso, and a head-neck. In this case, the root node would be the “human” and its children would be “upper body” and “lower body”. Each of these children would have children, and so on.
In the building example, the root node is a scene with the roof, building, and ground. The building is composed of floors, composed of walls, composed of wall and window blocks.
In the YMCA example, the root node is a scene with 4 humanoids, each humanoid with its own posture for the YMCA dance.

The “nodes” mapping maps each node to its name. Similarly, the meshes mapping maps each polygon mesh to its name. The textures mapping is a mapping of strings to strings - a texture is a 2d image (although 1d and 3d textures exist) that adds details to the surface of an object. These mappings exist so that complex OpenGL objects can be stored in nodes as strings, which optimizes space complexity in the nodes. When its time to draw, the scenegraph will provide the mapping of the object name to the object. Finally, there is an IScenegraphRenderer, which is used to render the scenenegraph. 

The draw method of the scenegraphrenderer is called by its associated scenegraph. The main utility in this scenegraphrenderer is to encapsulate all rendering specific code. Since we are using OpenGL, we create a GL3ScenegraphRenderer, which is an instance of an ISceneGraphRenderer. However, if we used a different library, we would create a different implementation of this ISceneGraphRenderer. The following represents the logical flow of the drawing process:

	1. The scenegraph calls draw, which delegates to scenegraphrenderer. 
	2. The scenegraphrenderer calls its draw method, which consumes its root node, and supplies the model view matrix stack for the operation. this draw function in turn delegates the drawing responsibilities to the root node.
	3. The node calls draw - this function consumes a context (for OpenGL drawing) and a model view matrix stack. A node can be a LeafNode, a TransformNode, or a GroupNode. A GroupNode has a List of child nodes. These can include leaf nodes, transform nodes, or group nodes themselves. If a node is to be transformed, a transform node will be formed and given 1 child. This transformation is then applied to its child, which can then be in turn applied to the child’s child. 
	4. The node, which contains the name of an object to be drawn, then calls the “draw mesh” function on the SceneGraphRenderer which it is supplied. This function encapsulates all the sending of the colors, vertex locations, and transformations to be sent to the shader program. 

As explained earlier, the GL3SceneGraphRenderer class encapsulates all of the OpenGL specific rendering code. In order to create a textual rendering of the scene graph, I would create a TextSceneGraphRenderer class that implements the ISceneGraphRenderer interface. Many of the functions promised by the interface would have trivial implementations (the text will not need a context, nor will it need to initialize a shader program. I would delegate the textual “drawing” to the root node, which would recursively call itself on its children. However, it would be bad design to create a NodetoString method in the abstractNode class and then implement it in every subclass, since nodes do not need this functionality. This can be circumvented via the visitor pattern - an INodeVisitor interface can promise visitLeaf, visitTransform, and visitGroup methods. A NodeToText class can implement this interface. Then all of the specific functionality can be implemented in each visit method of the NodeToText class. We can traverse each path from the root, accumulating the list of transformations in a string form. Once we reach the leaf, we will add this accumulated string to a list of strings that contains every leaf and all of the transformations applied to them. Minor implementation details will likely vary in practice. 